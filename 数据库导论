菜鸡本科生, 纯属个人理解, 恳请不吝斧正

感觉(关系型)数据库并不是一个很核心的课程, 考研的408里面也没有这部分.

为了引入(关系型)数据库, 不妨引入一个生活中的例子: 英语字典按照首字母进行了排序. 这使我们能够很方便地通过首字母(或前缀)来检索单词. 但是, 比如说我们在玩单词接龙, 我们想要查询以"x"结尾的单词, 一般的字典就不是那么好用了.

和英语字典对应的数据结构可以有很多, 如果不需要支持插入新的数据, 那就象是真实的书本一样, 用一个排序的数组即可. 如果要支持插入新的数据, 则可以用红黑树之类的各种平衡树. 在学习数据库之前你应该已经学了很多算法与数据结构, 应该已经了解了一些算法与数据结构所适合解决的问题.

但是, 如果我们面临着*未知*的查询需求, 我们应该如何预先设计数据呢? 

关系代数就是一个描述能力足够强的模型. 或者说, SQL就是能有效应对未知查询需求的一个中间层. 只要我们的数据结构足够强大, 以至于能够支持(几乎)任意基于关系代数的描述, 那么就(几乎)能够应对一切查询需求了.

上面有两个"几乎", 这也是SQL的设计的缺陷之一. 1: 现实中设计的, 能解释sql语句的程序, 支持能力有限, 
比如多表查询的嵌套层数一般不允许太深. 2: 也有一些复杂的查询, 是关系代数本身没有能力描述的, 不过对常用查询往往够用. 


https://v2ex.com/t/785947

数据库的范式不是从业务层面或效率层面出发的，而是从关系代数的描述能力出发的。

在为数据的增删查改提供 api 的时候，怎样的 api 才是必然足够的、拥有足够强的描述能力、必然无需后续再进行增加？关系代数给出了一个答案。（过强的描述能力也带来了安全性的问题）

但是，关系代数本身并未约束 table 的具体形式，我们容易意识到，把所有 table 自然连接成一个大表的话，会带来很多问题，教科书上对这些问题有足够的描述。我个人的概括是，这些问题要归咎于关系型数据库无法（完全）支持 lazy 特性。

那么，一个可以稍微弥补的方法，就是通过数据库的范式，约定好表的格式，从而间接地，对于一定的调用，我们可以一次性完成所需的操作，而不用对自然链接后的大 table 逐条执行。

但是，如果我们可以从业务层面确认，上述情况不会出现，或者出现的频率相比而言较低，把表细致的拆分就是不经济的。

